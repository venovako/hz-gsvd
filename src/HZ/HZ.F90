MODULE HZ
  IMPLICIT NONE

#ifdef LOGICAL_KIND
  INTEGER, PARAMETER :: LWP = LOGICAL_KIND
#else
  INTEGER, PARAMETER :: LWP = KIND(.FALSE.)
#endif

#ifdef INTEGER_KIND
  INTEGER, PARAMETER :: IWP = INTEGER_KIND
#else
  INTEGER, PARAMETER :: IWP = KIND(0)
#endif

#ifdef REAL_KIND
  INTEGER, PARAMETER :: RWP = REAL_KIND
#else
  INTEGER, PARAMETER :: RWP = KIND(0.0E0)
#endif

#ifdef DOUBLE_KIND
  INTEGER, PARAMETER :: DWP = DOUBLE_KIND
#else
  INTEGER, PARAMETER :: DWP = KIND(0.0D0)
#endif

  REAL, PARAMETER :: S_ZERO  =  0.0E0
  REAL, PARAMETER :: S_ONE   =  1.0E0
  REAL, PARAMETER :: S_MONE  = -1.0E0

  COMPLEX, PARAMETER :: C_ZERO  = (S_ZERO, S_ZERO)
  COMPLEX, PARAMETER :: C_ONE   = (S_ONE , S_ZERO)
  COMPLEX, PARAMETER :: C_MONE  = (S_MONE, S_ZERO)
  COMPLEX, PARAMETER :: C_IONE  = (S_ZERO, S_ONE )
  COMPLEX, PARAMETER :: C_MIONE = (S_ZERO, S_MONE)

  DOUBLE PRECISION, PARAMETER :: D_ZERO  =  0.0D0
  DOUBLE PRECISION, PARAMETER :: D_ONE   =  1.0D0
  DOUBLE PRECISION, PARAMETER :: D_MONE  = -1.0D0

  DOUBLE COMPLEX, PARAMETER :: Z_ZERO  = (D_ZERO, D_ZERO)
  DOUBLE COMPLEX, PARAMETER :: Z_ONE   = (D_ONE , D_ZERO)
  DOUBLE COMPLEX, PARAMETER :: Z_MONE  = (D_MONE, D_ZERO)
  DOUBLE COMPLEX, PARAMETER :: Z_IONE  = (D_ZERO, D_ONE )
  DOUBLE COMPLEX, PARAMETER :: Z_MIONE = (D_ZERO, D_MONE)

  INTERFACE FMA
     MODULE PROCEDURE SFMA, DFMA
  END INTERFACE FMA

  INTERFACE RSQRT
#ifdef USE_INTEL
     PURE FUNCTION SRSQRT(X) BIND(C,NAME='invsqrtf')
       USE, INTRINSIC :: ISO_C_BINDING
       IMPLICIT NONE
       REAL(c_float), INTENT(IN), VALUE :: X
       REAL(c_float) :: SRSQRT
     END FUNCTION SRSQRT
     PURE FUNCTION DRSQRT(X) BIND(C,NAME='invsqrt')
       USE, INTRINSIC :: ISO_C_BINDING
       IMPLICIT NONE
       REAL(c_double), INTENT(IN), VALUE :: X
       REAL(c_double) :: DRSQRT
     END FUNCTION DRSQRT
#else
     MODULE PROCEDURE SRSQRT, DRSQRT
#endif
  END INTERFACE RSQRT

CONTAINS

  PURE REAL FUNCTION SFMA(A, B, C)
    IMPLICIT NONE
    REAL, INTENT(IN) :: A, B, C
    !DIR$ FMA
    SFMA = A * B + C
  END FUNCTION SFMA

  PURE DOUBLE PRECISION FUNCTION DFMA(A, B, C)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(IN) :: A, B, C
    !DIR$ FMA
    DFMA = A * B + C
  END FUNCTION DFMA

#ifndef USE_INTEL
  ELEMENTAL REAL FUNCTION SRSQRT(X)
    IMPLICIT NONE
    REAL, INTENT(IN) :: X
    SRSQRT = S_ONE / SQRT(X)
  END FUNCTION SRSQRT

  ELEMENTAL DOUBLE PRECISION FUNCTION DRSQRT(X)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(IN) :: X
    DRSQRT = D_ONE / SQRT(X)
  END FUNCTION DRSQRT
#endif

! Threading support.
#include "BLAS_PREPARE.F90"
#include "BLAS_SET_NUM_THREADS.F90"
#include "GET_NTHR.F90"

! I/O support.
#include "GET_IOUNIT.F90"

! Timing support.
#include "TIMER_START.F90"
#include "TIMER_STOP.F90"
#include "TIMER_PRINT.F90"
#include "TIMER2DBLE.F90"

! Shuffler.
#include "INITSH.F90"
#include "BACKSH.F90"

! Partitioner.
#include "PARTBL.F90"

! Stepper.
#include "STRINI.F90"
#include "MMSTEP.F90"

! Hari-Zimmermann, Levels 0, 1, 2.
#include "ZIMMER.F90"

END MODULE HZ
